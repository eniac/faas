Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, 
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER 
IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR 
PERFORMANCE OF THIS SOFTWARE.

diff -Naur ./msieve-1.52/common/driver.c ./msieve-custom/common/driver.c
--- ./msieve-1.52/common/driver.c	2012-08-03 22:32:47.000000000 -0400
+++ ./msieve-custom/common/driver.c	2015-10-11 20:16:46.000000000 -0400
@@ -344,16 +344,25 @@
 
 		va_start(ap, fmt);
 		buf[0] = 0;
-		strcpy(buf, ctime(&t));
-		*(strchr(buf, '\n')) = 0;
-		fprintf(logfile, "%s  ", buf);
-		vfprintf(logfile, fmt, ap);
-		fclose(logfile);
-		va_end(ap);
+        ctime_r(&t, buf);
+        //strcpy(buf, ctime(&t));
+        char *result = strchr(buf, '\n');
+        if (result == NULL) { 
+            fprintf(logfile, "%s ", "unable to dereference buf");
+            exit(1);
+            // return;
+        } else { 
+            *result = 0;
+            fprintf(logfile, "%s  ", buf);
+            vfprintf(logfile, fmt, ap);
+            fclose(logfile);
+            va_end(ap);
+        }
 	}
 	if (obj->flags & MSIEVE_FLAG_LOG_TO_STDOUT) {
 		va_start(ap, fmt);
 		vfprintf(stdout, fmt, ap);
+        fflush(stdout);
 		va_end(ap);
 	}
 }
diff -Naur ./msieve-1.52/common/lanczos/lanczos.c ./msieve-custom/common/lanczos/lanczos.c
--- ./msieve-1.52/common/lanczos/lanczos.c	2013-06-22 15:25:41.000000000 -0400
+++ ./msieve-custom/common/lanczos/lanczos.c	2015-10-11 20:16:47.000000000 -0400
@@ -1222,7 +1222,7 @@
 
 				fprintf(stderr, "linear algebra completed %u "
 					"of %u dimensions (%1.1f%%, ETA "
-					"%dh%2dm)    \r",
+					"%dh%2dm)    \n",
 					dim_solved, max_n, 100.0 * dim_solved / 
 					max_n, eta / 3600, (eta % 3600) / 60);
 
diff -Naur ./msieve-1.52/common/lanczos/lanczos_io.c ./msieve-custom/common/lanczos/lanczos_io.c
--- ./msieve-1.52/common/lanczos/lanczos_io.c	2012-07-14 23:36:58.000000000 -0400
+++ ./msieve-custom/common/lanczos/lanczos_io.c	2015-10-11 20:16:47.000000000 -0400
@@ -337,6 +337,200 @@
 	*cycle_list_out = (la_col_t *)xrealloc(cycle_list, 
 				num_cycles * sizeof(la_col_t));
 }
+
+/*------------------------------------------------------------------
+
+Modification to msieve version 1.52
+
+Method: read_cycles_threaded()
+
+This is a modified version of read_cycles() that enables the 
+threading of the square root stage. 
+
+The key modification is that it creates lists of cycles (and relation
+ids within them) for each of the dependencies in one pass of the .cyc
+ cycle file.
+
+It also takes in uint32 pointers for dep_lower and dep_upper. This
+allows for the modification of dep_lower and dep_upper, as some of 
+the dependencies will not contain any cycles. This differs from the 
+original code, which due to its sequential nature would normally "hit"
+a "good" dependency before running out of dependencies.
+
+-------------------------------------------------------------------*/
+
+void read_cycles_threaded(msieve_obj *obj, 
+		la_dep_t **dep_cycle_list_out, 
+		uint32 *dep_lower,
+		uint32 *dep_upper) {
+
+	uint32 i;
+	uint32 j;
+	uint32 num_cycles;
+	uint32 max_cycles = 0;
+	uint32 rel_index[MAX_COL_IDEALS];
+	char buf[256];
+	FILE *cycle_fp;
+	FILE *dep_fp = NULL;
+	la_dep_t *dep_cycle_list = NULL;
+	uint64 mask = 0;
+	uint32 temp_dep_upper = *dep_upper;
+
+	/* open cycle file */
+	sprintf(buf, "%s.cyc", obj->savefile.name);
+	cycle_fp = fopen(buf, "rb");
+	if (cycle_fp == NULL) {
+		logprintf(obj, "error: read_cycles can't open cycle file\n");
+		exit(-1);
+	}
+
+	/* open dependency file */
+	sprintf(buf, "%s.dep", obj->savefile.name);
+	dep_fp = fopen(buf, "rb");
+	if (dep_fp == NULL) {
+		logprintf(obj, "error: read_cycles can't "
+				"open dependency file\n");
+		exit(-1);
+	}
+
+	/* read the total number of cycles, and allocate 
+	   sufficient space for each dependency to hold them */
+	fread(&num_cycles, sizeof(uint32), (size_t)1, cycle_fp);
+	logprintf(obj, "Sqrt: Assigning space for %u cycles for %u dependencies", 
+		      num_cycles, *dep_upper - *dep_lower + 1);
+	dep_cycle_list = (la_dep_t *)xcalloc((size_t)(*dep_upper - *dep_lower + 1),
+										 sizeof(la_dep_t));
+
+	for (i = *dep_lower; i <= *dep_upper; i++) {
+		la_dep_t *dep = dep_cycle_list + i - *dep_lower;
+		dep->column = xcalloc((size_t)num_cycles, sizeof(la_col_t));
+		dep->curr_cycle = 0;
+		dep->num_cycles = num_cycles;
+	}
+
+	/* read the relation numbers for each cycle and copy it to 
+	   all of the dependencies that it belongs to */
+	for (i = 0; i < num_cycles; i++) {
+		la_dep_t *dep;
+		la_col_t *c;
+		uint32 num_relations;
+		uint64 curr_dep;
+
+		if (fread(&num_relations, sizeof(uint32), 
+					(size_t)1, cycle_fp) != 1)
+			break;
+
+		if (num_relations > MAX_COL_IDEALS) {
+			printf("error: cycle too large; corrupt file?\n");
+			exit(-1);
+		}
+
+		if (fread(rel_index, sizeof(uint32), (size_t)num_relations, 
+					cycle_fp) != num_relations)
+			break;
+
+		/* all the relation numbers for this cycle
+		   have been read; save them and start the
+		   count for the next cycle. */
+
+		if (fread(&curr_dep, sizeof(uint64), 
+					(size_t)1, dep_fp) == 0) {
+			printf("dependency file corrupt\n");
+			exit(-1);
+		} 
+
+		mask = (uint64) 1 << (*dep_lower - 1);
+
+		for (j = *dep_lower; j <= *dep_upper; j++) {
+			if (mask & curr_dep) {
+				dep = dep_cycle_list + j - *dep_lower;
+				c = dep->column + dep->curr_cycle;
+				dep->curr_cycle++;
+
+				c->cycle.num_relations = num_relations;
+				c->cycle.list = (uint32 *)xmalloc(num_relations * 
+								sizeof(uint32));
+				memcpy(c->cycle.list, rel_index, 
+						num_relations * sizeof(uint32));
+			}
+			mask <<= 1;
+		}
+
+		
+	}
+
+	/* Assigns the correct number of cycles for each cycle.
+	   Also set the maximum number of cycles to ensure that at least
+	   one of the dependencies has a non-zero number of cycles */
+	for (i = *dep_lower; i <= *dep_upper; i++) {
+		la_dep_t *dep;
+
+		dep = dep_cycle_list + i - *dep_lower;
+
+		logprintf(obj, "Sqrt: For dependency %u, read %u cycles\n", i, 
+			      dep->curr_cycle);
+		dep->num_cycles = dep->curr_cycle;
+		max_cycles = MAX(max_cycles, dep->num_cycles);
+	}
+
+	/* Checks all of the cycles to ensure that none of them are empty. */
+	for (i = *dep_lower; i <= *dep_upper; i++) {
+		la_dep_t *dep;
+
+		dep = dep_cycle_list + i - *dep_lower;
+
+		for (j = 0; j < dep->num_cycles; j++) {
+			if (dep->column[j].cycle.num_relations == 0) {
+				logprintf(obj, "error: empty cycle encountered\n");
+				exit(-1);
+			}
+		}
+	}
+	fclose(cycle_fp);
+	fclose(dep_fp);
+
+	/* Check to ensure that at least one of the dependencies 
+	   has a non-zero number of cycles */
+	if (max_cycles == 0) {
+		for (i = *dep_lower; i <= *dep_upper; i++) {
+			la_dep_t *dep;
+
+			dep = dep_cycle_list + i - *dep_lower;
+			free(dep->column);
+		}
+		free(dep_cycle_list);
+		*dep_cycle_list_out = NULL;
+		logprintf(obj, "Sqrt: error: no dependencies with non-zero cycles");
+		return;
+	}
+
+	/* Reallocate the memory as the number of cycles per dep is probably
+	   less than the total number of cycles. If the dependency has no cycles,
+	   free it and change the dep_upper bound. 
+	   Reallocate the entire dependency list as well. */
+	for (i = *dep_lower; i <= *dep_upper; i++) {
+		la_dep_t *dep;
+
+		dep = dep_cycle_list + i - *dep_lower;
+
+		if (dep->num_cycles == 0) {
+			temp_dep_upper = MIN(i - 1, temp_dep_upper);
+			free(dep->column);
+		} else {
+			dep->column = (la_col_t *)xrealloc(dep->column, dep->num_cycles *
+											   sizeof(la_col_t));
+		}
+	}
+
+	*dep_upper = temp_dep_upper;
+	dep_cycle_list = (la_dep_t *)xrealloc(dep_cycle_list, 
+										  (*dep_upper - *dep_lower + 1) *
+										  sizeof(la_dep_t));
+
+	*dep_cycle_list_out = dep_cycle_list;
+}
+
+
 /*--------------------------------------------------------------------*/
 static int compare_uint32(const void *x, const void *y) {
 	uint32 *xx = (uint32 *)x;
diff -Naur ./msieve-1.52/gnfs/gnfs.c ./msieve-custom/gnfs/gnfs.c
--- ./msieve-1.52/gnfs/gnfs.c	2013-06-22 09:16:18.000000000 -0400
+++ ./msieve-custom/gnfs/gnfs.c	2015-10-11 20:16:47.000000000 -0400
@@ -42,7 +42,17 @@
 
 static uint32 nfs_init_savefile(msieve_obj *obj, mpz_t n);
 
-/*--------------------------------------------------------------------*/
+/*------------------------------------------------------------------
+
+Modification to msieve version 1.52
+
+Method: factor_gnfs()
+
+The only modification is to call nfs_find_factors_threaded() instead
+of nfs_find_factors().
+
+-------------------------------------------------------------------*/
+
 uint32 factor_gnfs(msieve_obj *obj, mp_t *input_n,
 			factor_list_t *factor_list) {
 
@@ -165,7 +175,7 @@
 		nfs_solve_linear_system(obj, n);
 		
 	if (obj->flags & MSIEVE_FLAG_NFS_SQRT)
-		factor_found = nfs_find_factors(obj, n, factor_list);
+		factor_found = nfs_find_factors_threaded(obj, n, factor_list);
 
 finished:
 	mpz_poly_free(&rat_poly);
diff -Naur ./msieve-1.52/gnfs/gnfs.h ./msieve-custom/gnfs/gnfs.h
--- ./msieve-1.52/gnfs/gnfs.h	2013-06-15 22:25:22.000000000 -0400
+++ ./msieve-custom/gnfs/gnfs.h	2015-10-11 20:16:47.000000000 -0400
@@ -56,6 +56,30 @@
 		mpz_init_set_ui(poly->coeff[i], 0);
 }
 
+/*------------------------------------------------------------------
+
+Modification to msieve version 1.52
+
+Method: mpz_poly_copy()
+
+This is a bug fix to the existing mpz_poly_copy() code. A simple 
+memcpy is not sufficient for mpz_t. It must be set correctly using
+the mpz_set() method.
+
+-------------------------------------------------------------------*/
+
+static INLINE void mpz_poly_copy(mpz_poly_t *dst, mpz_poly_t * src) {
+	uint32 i;
+	dst->degree = src->degree;
+
+	for (i = 0; i <= MAX_POLY_DEGREE; i++)
+		mpz_set(dst->coeff[i], src->coeff[i]);
+
+	mpz_set(dst->tmp1, src->tmp1);
+	mpz_set(dst->tmp2, src->tmp2);
+	mpz_set(dst->tmp3, src->tmp3);
+}
+
 static INLINE void mpz_poly_free(mpz_poly_t * poly) {
 	uint32 i;
 
@@ -262,6 +286,34 @@
 uint32 nfs_find_factors(msieve_obj *obj, mpz_t n, 
 			factor_list_t *factor_list);
 
+/*------------------------------------------------------------------
+
+Modification to msieve version 1.52
+
+Method: nfs_find_factors_threaded()
+
+Implements a threaded version of nfs_find_factors(), where multiple
+dependencies are worked on at the same time. This eliminates the 
+non-deterministic runtime of nfs_find_factors(), where the time taken
+would scale linearly with the number of "bad" dependencies it encounters.
+
+Currently, all threads are given new tasks at the same time. This is
+to allow all of the threads to finish first, and allow the master thread
+to check if the factor has been found. 
+
+A modification that could be made in the future to modify the threading
+code to allow each thread to be killed at any time. This is a major
+nightmare due to the fact that mutexes are involved and memory is freed
+during the execution of thread, so I have not implemented it here.
+
+As we must wait for all threads to complete, there is a ~10% overhead
+here compared to the time it takes to work on one dependency only.
+
+-------------------------------------------------------------------*/
+
+uint32 nfs_find_factors_threaded(msieve_obj *obj, mpz_t n,
+			factor_list_t *factor_list);
+
 /*------------------- relation processing stuff --------------------------*/
 
 #define RATIONAL_IDEAL 0
@@ -333,6 +385,25 @@
 				 factors first, then algebraic */
 } relation_t;
 
+
+/*------------------------------------------------------------------
+
+Modification to msieve version 1.52
+
+Struct: relation_lists_t
+
+Allows the store of a list of relations for multiple dependencies.
+
+-------------------------------------------------------------------*/
+
+
+typedef struct relation_lists_t {
+	uint32 dep_no;
+	uint32 num_relations;
+	relation_t *rlist;
+
+} relation_lists_t;
+
 /* structure used to conveniently represent all of
    the large ideals that occur in a relation. The
    structure is far too large to be useful when 
@@ -383,6 +454,29 @@
 			relation_t **relation_list, uint32 compress,
 			uint32 dependency);
 
+/*------------------------------------------------------------------
+
+Modification to msieve version 1.52
+
+Method: nfs_read_cycles_threaded()
+
+This is a modified version of nfs_read_cycles() that enables the 
+threading of the square root stage. 
+
+Using the modified read_cycles_threaded() and 
+nfs_get_cycle_relations_threaded(), it allows us to create lists of 
+relations for each of the dependencies in one pass of the .cyc cycle 
+file and the .dat relation file. 
+
+By creating all of the dependency relations objects in one go, 
+this allows us to save on file IO time and to create threads for 
+multiple dependencies at the same time.
+
+-------------------------------------------------------------------*/
+
+void nfs_read_cycles_threaded(msieve_obj *obj, factor_base_t *fb, relation_lists_t **rlists, 
+			uint32 *dep_lower, uint32 *dep_upper);
+
 void nfs_free_relation_list(relation_t *rlist, uint32 num_relations);
 
 void nfs_convert_cado_cycles(msieve_obj *obj);
diff -Naur ./msieve-1.52/gnfs/relation.c ./msieve-custom/gnfs/relation.c
--- ./msieve-1.52/gnfs/relation.c	2014-02-04 10:39:11.000000000 -0500
+++ ./msieve-custom/gnfs/relation.c	2015-10-11 20:16:47.000000000 -0400
@@ -474,6 +474,7 @@
 	uint32 count;
 } relcount_t;
 
+
 static void nfs_get_cycle_relations(msieve_obj *obj, 
 				factor_base_t *fb, uint32 num_cycles, 
 				la_col_t *cycle_list, 
@@ -612,6 +613,245 @@
 	mpz_clear(scratch);
 }
 
+/*------------------------------------------------------------------
+
+Modification to msieve version 1.52
+
+Struct: relcount_thread_t
+
+This is a modified version of relcount_t. It allows for the storage
+of a dependency flag. If the bit is set, then the relation belongs
+to the dependency in question. This allows for the relations file to
+be read in one pass, and have all of the relations copied to the 
+appropriate dependencies.
+
+Used in nfs_get_cycle_relations_threaded() mainly.
+
+-------------------------------------------------------------------*/
+
+typedef struct {
+	uint32 relidx;
+	uint64 dep_flags;
+} relcount_thread_t;
+
+/*------------------------------------------------------------------
+
+Modification to msieve version 1.52
+
+Method: compare_relcount_thread()
+
+This is a comparator that is used in the quicksort method. This
+allows for the sorting of all of the relcount_thread_t structs 
+based on their relidx.
+
+Used in nfs_get_cycle_relations_threaded()
+
+-------------------------------------------------------------------*/
+
+int compare_relcount_thread (const void * a, const void * b) {
+	return compare_uint32(&(((relcount_thread_t *) a)->relidx), 
+				&(((relcount_thread_t *) b)->relidx));
+}
+
+/*------------------------------------------------------------------
+
+Modification to msieve version 1.52
+
+Method: nfs_get_cycle_relations_threaded()
+
+This is a modified version of nfs_get_cycle_relations() that enables the 
+threading of the square root stage. 
+
+The key modification is that it creates lists of relations for each of 
+the dependencies in one pass of the .dat relation file. By creating all
+of the dependency relations objects in one go, this allows us to save on 
+file IO time and to create threads for multiple dependencies at the same time.
+
+-------------------------------------------------------------------*/
+
+static void nfs_get_cycle_relations_threaded(msieve_obj *obj, 
+				factor_base_t *fb, la_dep_t *dep_cycle_list,
+				relation_lists_t **dep_rel_list_out,
+				uint32 dep_lower,
+				uint32 dep_upper) {
+	uint32 i, j, k;
+	char buf[LINE_BUF_SIZE];
+	relation_lists_t *dep_rel_list;
+	savefile_t *savefile = &obj->savefile;
+
+	hashtable_t unique_relidx;
+	uint32 num_unique_relidx;
+	relcount_thread_t *relidx_list;
+	relcount_thread_t *entry;
+
+	uint8 tmp_factors[COMPRESSED_P_MAX_SIZE];
+	uint32 factor_size;
+	relation_t tmp_relation;
+	mpz_t scratch;
+
+	tmp_relation.factors = tmp_factors;
+
+	hashtable_init(&unique_relidx, 
+			(uint32)WORDS_IN(relcount_thread_t), 
+			(uint32)1);
+
+	/* Fill the hashtable using the relation ids for each dependency obtained
+	in read_cycles_threaded(). If the relation has already been added, simply 
+	toggle the bit in relcount_thread_t belonging to the struct. 
+
+	Doing this also neatly "squeezes" out the relations that occurs an 
+	even number of times.
+	(author: not entirely sure why "squeezing" is necessary, but the same 
+	 operation is performed in nfs_get_cycle_relations(), so I figured it 
+	 should be included) */
+
+	for (i = dep_lower; i <= dep_upper; i++) {
+		la_dep_t *dep = dep_cycle_list + i - dep_lower;
+		for (j = 0; j < dep->num_cycles; j++) {
+			la_col_t *c = dep->column + j;
+			uint32 num_relations = c->cycle.num_relations;
+			uint32 *list = c->cycle.list;
+
+			for (k = 0; k < num_relations; k++) {
+				uint32 already_seen;
+				entry = (relcount_thread_t *)hashtable_find(
+							&unique_relidx, list + k, 
+							NULL, &already_seen);
+				if (!already_seen)
+					entry->dep_flags = 1 << (i - 1);
+				else
+					entry->dep_flags ^= 1 << (i - 1);
+			}
+		}
+	}
+
+	/* Convert the internal list of hashtable entries into
+	   a list of relcount_thread_t. Discard all relcount_thread_t where the
+	   dependency flag is 0 (it has been squeezed out from all deps) */
+
+	hashtable_close(&unique_relidx);
+	num_unique_relidx = hashtable_get_num(&unique_relidx);
+	entry = (relcount_thread_t *)hashtable_get_first(&unique_relidx);
+	relidx_list = (relcount_thread_t *)unique_relidx.match_array;
+
+	for (i = j = 0; i < num_unique_relidx; i++) {
+		if (entry->dep_flags != 0)
+			relidx_list[j++] = *entry;
+
+		entry = (relcount_thread_t *)hashtable_get_next(
+					&unique_relidx, entry);
+	}
+	num_unique_relidx = j;
+
+	/* sort the list in order of increasing relation number */
+	qsort(relidx_list, (size_t)num_unique_relidx, 
+		sizeof(relcount_thread_t), compare_relcount_thread);
+
+	logprintf(obj, "Sqrt: cycles contain %u unique relations\n", 
+				num_unique_relidx);
+
+	savefile_open(savefile, SAVEFILE_READ);
+
+	/* assign space for relation lists for each dependency */
+	dep_rel_list = (relation_lists_t *)xcalloc((size_t)(dep_upper 
+		                                                - dep_lower + 1), 
+											   sizeof(relation_lists_t));
+
+	for (i = dep_lower; i <= dep_upper; i++) {
+		relation_lists_t *rlists;
+
+		rlists = dep_rel_list + i - dep_lower;
+		rlists->rlist = (relation_t *)xcalloc((size_t) num_unique_relidx,
+											  sizeof(relation_t));
+		rlists->dep_no = i;
+		rlists->num_relations = 0;
+	}
+	
+	/* read the list of relations */
+
+	i = (uint32)(-1);
+	j = 0;
+	savefile_read_line(buf, sizeof(buf), savefile);
+	mpz_init(scratch);
+	while (!savefile_eof(savefile) && j < num_unique_relidx) {
+		
+		int32 status;
+
+		if (buf[0] != '-' && !isdigit(buf[0])) {
+
+			/* no relation at this line */
+
+			savefile_read_line(buf, sizeof(buf), savefile);
+			continue;
+		}
+		if (++i < relidx_list[j].relidx) {
+
+			/* relation not needed */
+
+			savefile_read_line(buf, sizeof(buf), savefile);
+			continue;
+		}
+
+		status = nfs_read_relation(buf, fb, &tmp_relation, 
+						&factor_size, 0,
+						scratch);
+		if (status) {
+			/* at this point, if the relation couldn't be
+			   read then the filtering stage should have
+			   found that out and skipped it */
+
+			logprintf(obj, "error: relation %u corrupt\n", i);
+			exit(-1);
+		}
+		else {
+
+			/* Iterate through all of the dependencies. 
+			   Save the relation if it matches the dependency */
+			for (k = dep_lower; k <= dep_upper; k++) {
+				if (relidx_list[j].dep_flags & (1 << (k - 1))) {
+					relation_lists_t *rlists;
+					relation_t *r;
+
+					rlists = dep_rel_list + k - dep_lower;
+					r = rlists->rlist + rlists->num_relations;
+
+					*r = tmp_relation;
+					r->rel_index = i;
+					r->factors = (uint8 *)xmalloc(factor_size *
+							sizeof(uint8));
+					memcpy(r->factors, tmp_relation.factors,
+							factor_size * sizeof(uint8));
+
+					rlists->num_relations++;
+				}
+			}
+			j++;
+		}
+
+		savefile_read_line(buf, sizeof(buf), savefile);
+	}
+
+	num_unique_relidx = j;
+	logprintf(obj, "Sqrt: read %u relations in total\n", j);
+
+	/* Reallocate memory for each dependency, as no dependency is likely to
+	   have each relation in it */
+	for (i = dep_lower; i <= dep_upper; i++) {
+		relation_lists_t *rlists;
+
+		rlists = dep_rel_list + i - dep_lower;
+		rlists->rlist = (relation_t *)xrealloc(rlists->rlist,
+					(size_t) (rlists->num_relations * sizeof(relation_t)));
+		logprintf(obj, "Sqrt: Dependency %u has %u relations\n", i, 
+			      rlists->num_relations);
+	}
+
+	savefile_close(savefile);
+	hashtable_free(&unique_relidx);
+	*dep_rel_list_out = dep_rel_list;
+	mpz_clear(scratch);
+}
+
 /*--------------------------------------------------------------------*/
 void nfs_read_cycles(msieve_obj *obj, 
 			factor_base_t *fb,
@@ -682,6 +922,60 @@
 	}
 }
 
+/*------------------------------------------------------------------
+
+Modification to msieve version 1.52
+
+Method: nfs_read_cycles_threaded()
+
+This is a modified version of nfs_read_cycles() that enables the 
+threading of the square root stage. 
+
+Using the modified read_cycles_threaded() and 
+nfs_get_cycle_relations_threaded(), it allows us to create lists of 
+relations for each of the dependencies in one pass of the .cyc cycle 
+file and the .dat relation file. 
+
+By creating all of the dependency relations objects in one go, 
+this allows us to save on file IO time and to create threads for 
+multiple dependencies at the same time.
+
+-------------------------------------------------------------------*/
+
+void nfs_read_cycles_threaded(msieve_obj *obj, 
+			factor_base_t *fb,
+			relation_lists_t **rlists,
+			uint32 *dep_lower, 
+			uint32 *dep_upper) {
+
+	int i;
+	la_dep_t *dep_cycle_list = NULL;
+	relation_lists_t *dep_rel_list = NULL;
+
+	/* read the raw list of relation numbers for each cycle and dependency */
+	read_cycles_threaded(obj, &dep_cycle_list, dep_lower, dep_upper);
+
+	if (dep_cycle_list == NULL) {
+		*rlists = NULL;
+		return;
+	}
+
+	/* now read the list of relations needed by the
+	   list of cycles */
+	nfs_get_cycle_relations_threaded(obj, fb, dep_cycle_list, 
+				&dep_rel_list, *dep_lower, *dep_upper);
+
+	/* need to free dep_cycle_list */
+
+	for (i = *dep_lower; i <= *dep_upper; i++) {
+		la_dep_t *dep = dep_cycle_list + i - *dep_lower;
+		free_cycle_list(dep->column, dep->num_cycles);
+	}
+	free(dep_cycle_list);
+	
+	*rlists = dep_rel_list;
+}
+
 /*--------------------------------------------------------------------*/
 void nfs_free_relation_list(relation_t *rlist, uint32 num_relations) {
 
diff -Naur ./msieve-1.52/gnfs/sqrt/sqrt.c ./msieve-custom/gnfs/sqrt/sqrt.c
--- ./msieve-1.52/gnfs/sqrt/sqrt.c	2013-07-04 08:00:42.000000000 -0400
+++ ./msieve-custom/gnfs/sqrt/sqrt.c	2015-10-11 20:16:47.000000000 -0400
@@ -548,3 +548,742 @@
 
 	return factor_found;
 }
+
+/*------------------------------------------------------------------
+
+Modification to msieve version 1.52
+
+Method: sqrt_fb_light_init()
+
+This is performs a light initialization of the mpz_poly structs
+in the factor_base_t.
+
+Used only in sqrt_data_init()
+
+-------------------------------------------------------------------*/
+
+void sqrt_fb_light_init (factor_base_t *fb) {
+	memset(fb, 0, sizeof(factor_base_t));
+	mpz_poly_init(&(fb->rfb.poly));
+	mpz_poly_init(&(fb->afb.poly));
+}
+
+/*------------------------------------------------------------------
+
+Modification to msieve version 1.52
+
+Method: sqrt_fb_light_copy_a_r_poly()
+
+This is performs a light copy of the mpz_poly structs
+in the factor_base_t.
+
+Used only in sqrt_data_deep_copy()
+
+-------------------------------------------------------------------*/
+
+void sqrt_fb_light_copy_a_r_poly (factor_base_t *dst, factor_base_t *src) {
+	mpz_poly_copy(&(dst->rfb.poly), &(src->rfb.poly));
+	mpz_poly_copy(&(dst->afb.poly), &(src->afb.poly));
+}
+
+/*------------------------------------------------------------------
+
+Modification to msieve version 1.52
+
+Method: sqrt_data_init()
+
+This is performs a initialization of the sqrt_data struct.
+
+Used in sqrt_data_deep_copy() and nfs_find_factors_threaded().
+
+-------------------------------------------------------------------*/
+
+void sqrt_data_init (sqrt_data *dat) {
+	sqrt_fb_light_init(&(dat->fb));
+	dat->apoly = &(dat->fb.afb.poly);
+	dat->rpoly = &(dat->fb.rfb.poly);
+	mpz_poly_init(&(dat->monic_alg_poly));
+	mpz_init(dat->exponent);
+	mpz_init(dat->sqrt_r);
+	mpz_init(dat->sqrt_a);
+	mpz_init(dat->c);
+	mpz_init(dat->tmp1);
+	mpz_init(dat->tmp2);
+}
+
+/*------------------------------------------------------------------
+
+Modification to msieve version 1.52
+
+Method: sqrt_data_deep_copy()
+
+This is performs a deep copy of the sqrt_data struct. Only pass 
+in an uninitialized, but memory allocated, sqrt_data pointer as
+dst. The current method does not do the correct checking to
+ensure memory-safety otherwise.
+
+Used in nfs_find_factors_threaded() in order to make a copy of
+sqrt_data for each of the threads.
+
+-------------------------------------------------------------------*/
+
+void sqrt_data_deep_copy (sqrt_data *dst, sqrt_data *src) {
+	sqrt_data_init(dst);
+	dst->check_q = src->check_q;
+	sqrt_fb_light_copy_a_r_poly(&(dst->fb), &(src->fb));
+	mpz_poly_copy(&(dst->monic_alg_poly), &(src->monic_alg_poly));
+	mpz_set(dst->exponent, src->exponent);
+	mpz_set(dst->sqrt_r, src->sqrt_r);
+	mpz_set(dst->sqrt_a, src->sqrt_a);
+	mpz_set(dst->c, src->c);
+	mpz_set(dst->tmp1, src->tmp1);
+	mpz_set(dst->tmp2, src->tmp2);
+}
+
+/*------------------------------------------------------------------
+
+Modification to msieve version 1.52
+
+Method: free_sqrt_data()
+
+Frees sqrt_data.
+
+Used in nfs_find_factors_threaded() and sqrt_thread_shutdown()
+
+-------------------------------------------------------------------*/
+
+void free_sqrt_data (sqrt_data *dat) {
+	mpz_poly_free(&(dat->fb.rfb.poly));
+	mpz_poly_free(&(dat->fb.afb.poly));
+	mpz_poly_free(&(dat->monic_alg_poly));
+	mpz_clear(dat->exponent);
+	mpz_clear(dat->sqrt_r);
+	mpz_clear(dat->sqrt_a);
+	mpz_clear(dat->c);
+	mpz_clear(dat->tmp1);
+	mpz_clear(dat->tmp2);
+
+	free(dat);
+}
+
+/*------------------------------------------------------------------
+
+Modification to msieve version 1.52
+
+Method: sqrt_thread_data_init()
+
+Initializes the data object required by each thread.
+
+Used in nfs_find_factors_threaded().
+
+-------------------------------------------------------------------*/
+
+void sqrt_thread_data_init(msieve_obj *obj, 
+				sqrt_thread_data *thread_dat, 
+				sqrt_data *dat, relation_lists_t *rl, 
+				pthread_mutex_t *factor_found_mutex,
+				pthread_mutex_t *status_mutex, 
+				pthread_cond_t *status_cond, int *status, 
+				pthread_mutex_t *count_mutex, int *count,
+				mpz_t n, factor_list_t *factor_list) {
+
+	thread_dat->dat = (sqrt_data *)xcalloc((size_t) 1, sizeof(sqrt_data));
+	sqrt_data_deep_copy(thread_dat->dat, dat);
+	thread_dat->dep_no = rl->dep_no;
+	thread_dat->rlist = rl->rlist;
+	thread_dat->num_relations = rl->num_relations;
+	thread_dat->factor_found_mutex = factor_found_mutex;
+	thread_dat->status_mutex = status_mutex;
+	thread_dat->status_cond = status_cond;
+	thread_dat->count_mutex = count_mutex;
+	thread_dat->count = count;
+	thread_dat->status = status;
+	thread_dat->obj = obj;
+	mpz_init(thread_dat->n);
+	mpz_set(thread_dat->n, n);
+	thread_dat->factor_list = factor_list;
+}
+
+/*------------------------------------------------------------------
+
+Modification to msieve version 1.52
+
+Method: free_sqrt_thread_data()
+
+Frees the thread data object upon completion of the thread.
+
+Used in nfs_find_factors_threaded() and sqrt_thread_shutdown().
+
+-------------------------------------------------------------------*/
+
+void free_sqrt_thread_data(sqrt_thread_data *data) {
+	mpz_clear(data->n);
+	free_sqrt_data(data->dat);
+}
+
+/*------------------------------------------------------------------
+
+Modification to msieve version 1.52
+
+Method: sqrt_thread_shutdown()
+
+Performs necessary clean up of thread data after the task is complete.
+
+Used in nfs_find_factors_threaded().
+
+-------------------------------------------------------------------*/
+
+void sqrt_thread_shutdown(void *arg, int thread_num) {
+	sqrt_thread_data *data = (sqrt_thread_data *) arg;
+
+	logprintf(data->obj, "Sqrt: Thread %u shutting down dep_task %u\n", 
+					thread_num, data->dep_no);
+
+	/* Update the number of completed dependencies */
+	if (pthread_mutex_lock(data->count_mutex)) {
+		perror("pthread_mutex_lock...");
+	}
+	*(data->count) = *(data->count) + 1;
+	if (pthread_mutex_unlock(data->count_mutex)) {
+		perror("pthread_mutex_unlock...");
+	}
+
+	/* Let the master check if we are done */
+	if (pthread_mutex_lock(data->status_mutex)) {
+		perror("pthread_mutex_lock...");
+	}
+	pthread_cond_broadcast(data->status_cond);
+	if (pthread_mutex_unlock(data->status_mutex)) {
+		perror("pthread_mutex_unlock...");
+	}
+
+	free_sqrt_thread_data(data);
+}
+
+/*------------------------------------------------------------------
+
+Modification to msieve version 1.52
+
+Method: sqrt_thread_find_factor()
+
+Method that each thread runs to compute each dependency.
+
+-------------------------------------------------------------------*/
+
+void sqrt_thread_find_factor(void *data, int thread_num) {
+	
+	int i;
+	sqrt_thread_data *init = (sqrt_thread_data *) data;
+	msieve_obj *obj = init->obj;
+	sqrt_data *dat = init->dat;
+	pthread_mutex_t *factor_found_mutex = init->factor_found_mutex;
+	pthread_mutex_t *status_mutex = init->status_mutex;
+	int *status = init->status;
+	uint32 num_relations = init->num_relations;
+	uint32 num_free_relations;
+	uint32 dep_no = init->dep_no;
+	relation_t *rlist = init->rlist;
+	abpair_t *abpairs = init->abpairs;
+	factor_list_t *factor_list = init->factor_list;
+
+	logprintf(obj, "Sqrt: Thread %u working on dependency %u\n", 
+			  thread_num, dep_no);
+
+	if (num_relations == 0)
+		return;
+
+	/* do some sanity checking, performing increasing
+	   amounts of work as the dependency proves itself
+	   to be valid */
+
+	if (num_relations % 2) {
+		/* the LA is supposed to force the number of 
+		   relations in the dependency to be even. 
+		   This isn't necessary if the leading coeff of
+		   both NFS polynomials are squares, or if both
+		   NFS polynomials are monic, since the 
+		   corrections below that need the number of 
+		   relations are avoided. But only a small 
+		   minority of NFS jobs would satisfy this condition */
+
+		logprintf(obj, "Sqrt: Dependency %u failed: number of relations" 
+			      "is not even\n", dep_no);
+		return;
+	}
+
+
+	if (verify_alg_ideal_powers(rlist, 
+			num_relations, &num_free_relations) != 0) {
+		logprintf(obj, "Sqrt: Dependency %u failed: algebraic side is not "
+				  "a square!\n", dep_no);
+		return;
+	}
+	if (num_free_relations % 2) {
+		logprintf(obj, "Sqrt: Dependency %u failed: number of free relations"
+		   		  " (%u) is not even\n", dep_no, num_free_relations);
+		return;
+	}
+	if (rat_square_root(rlist, num_relations, init->n, dat->sqrt_r) != 0) {
+		logprintf(obj, "Sqrt: Dependency %u failed: rational side is not "
+			      "a square!\n", dep_no);
+		return;
+	}
+
+
+	/* flatten the list of relations; each occurrence of
+	   a relation gets its own abpair_t */
+
+	abpairs = (abpair_t *)xmalloc(num_relations *
+					sizeof(abpair_t));
+
+	for (i = 0; i < num_relations; i++) {
+		abpairs[i].a = rlist[i].a;
+		abpairs[i].b = rlist[i].b;
+	}
+
+	nfs_free_relation_list(rlist, num_relations);
+
+	/* perform the major work: the algebraic square root.
+	   Note that to conserve memory, abpairs is freed in
+	   the following call */
+	logprintf(obj, "Sqrt: Thread %u beginning algebraic square root "
+			  "for dependency %u\n", thread_num, dep_no);
+	mpz_set_ui(dat->sqrt_a, 0);
+	alg_square_root(obj, &(dat->monic_alg_poly), init->n, dat->c, 
+							 dat->rpoly->coeff[1], dat->rpoly->coeff[0], 
+							 abpairs, num_relations, dat->check_q, 
+							 dat->sqrt_a);
+	if (mpz_sgn(dat->sqrt_a) == 0) {
+		logprintf(obj, "Sqrt: Thread %u: dependency %u, algebraic square "
+			"root failed\n", thread_num, dep_no);
+		return;
+	}
+
+	/* an algebraic square root is available; move on
+	   to the final congruence of squares. The arithmetic
+	   is as given in Buhler et. al. with one exception:
+	   when the rational poly is nonmonic there is a 
+	   correction to the final square root value but the 
+	   free relations *do not* figure into it. This latter
+	   point is completely ignored in the literature! */
+	logprintf(obj, "Sqrt: Thread %u beginning congruence of squares "
+			  "for dependency %u\n", thread_num, dep_no);
+
+	eval_poly_derivative(dat->apoly, dat->rpoly->coeff[1], 
+				dat->rpoly->coeff[0], init->n, dat->tmp1);
+	mpz_mul(dat->sqrt_r, dat->sqrt_r, dat->tmp1);
+	mpz_mod(dat->sqrt_r, dat->sqrt_r, init->n);
+
+	mpz_set_ui(dat->exponent, 0);
+	if (mpz_cmp_ui(dat->c, 1) != 0) {
+		mpz_set_ui(dat->exponent, num_relations / 2 + 
+					dat->apoly->degree - 2);
+		mpz_powm(dat->tmp1, dat->c, dat->exponent, init->n);
+		mpz_mul(dat->sqrt_r, dat->sqrt_r, dat->tmp1);
+		mpz_mod(dat->sqrt_r, dat->sqrt_r, init->n);
+	}
+
+	if (mpz_cmp_ui(dat->rpoly->coeff[1], 1) != 0) {
+		mpz_set_ui(dat->exponent, (num_relations -
+			       		num_free_relations) / 2);
+		mpz_set(dat->tmp1, dat->rpoly->coeff[1]);
+
+		if (mpz_sgn(dat->tmp1) < 0)
+			mpz_add(dat->tmp1, dat->tmp1, init->n);
+
+		mpz_powm(dat->tmp2, dat->tmp1, dat->exponent, init->n);
+		mpz_mul(dat->sqrt_a, dat->sqrt_a, dat->tmp2);
+		mpz_mod(dat->sqrt_a, dat->sqrt_a, init->n);
+	}
+
+	/* a final sanity check: square the rational and algebraic 
+	   square roots, expecting the same value modulo n */
+
+	mpz_mul(dat->tmp1, dat->sqrt_r, dat->sqrt_r);
+	mpz_mul(dat->tmp2, dat->sqrt_a, dat->sqrt_a);
+	mpz_mod(dat->tmp1, dat->tmp1, init->n);
+	mpz_mod(dat->tmp2, dat->tmp2, init->n);
+	if (mpz_cmp(dat->tmp1, dat->tmp2) != 0) {
+		logprintf(obj, "Sqrt: Thread %u: dependency %u does not form a "
+				"congruence of squares!\n", thread_num, dep_no);
+		return;
+	}
+
+	/* look for a nontrivial factor of n */
+
+	mpz_add(dat->tmp1, dat->sqrt_r, dat->sqrt_a);
+	mpz_gcd(dat->tmp1, dat->tmp1, init->n);
+
+	if (mpz_cmp_ui(dat->tmp1, 1) == 0) {
+		logprintf(obj, "Sqrt: Thread %u: dependency %u, "
+			      "GCD is 1, no factor found\n",thread_num, dep_no);
+	}
+	else if (mpz_cmp(dat->tmp1, init->n) == 0) {
+		logprintf(obj, "Sqrt: Thread %u: dependency %u, "
+		          "GCD is N, no factor found\n", thread_num, dep_no);
+	}
+	else {
+		/* factor found; add it to the list of factors. 
+		   Stop trying dependencies if the remaining
+		   composite is small enough that another method
+		   will factor it faster.
+
+		   Actually, we should be stopping when the remaining
+		   composite is much larger (70-80 digits), but 
+		   avoid doing this because the MPQS code will run
+		   and wipe out all the NFS relations we've collected */
+
+		/* If the factor has already been found from another thread,
+		   stop calling factor_found to avoid confusing the rest of 
+		   msieve code */
+
+		if (pthread_mutex_lock(status_mutex)) {
+			perror("pthread_mutex_lock for factor_found");
+			return;
+		}
+
+		if (*status) {
+			if (pthread_mutex_unlock(status_mutex)) {
+				perror("pthread_mutex_lock for factor_found");
+				return;
+			}
+			return;
+		}
+
+		if (pthread_mutex_unlock(status_mutex)) {
+			perror("pthread_mutex_lock for factor_found");
+			return;
+		}
+
+		/*  Lock out the factor_found portion to prevent 
+			unspecified behavior from factor_list_add() 
+			which is not known to be thread-safe */
+		if (pthread_mutex_lock(factor_found_mutex)) {
+			perror("pthread_mutex_lock for factor_found");
+			return;
+		}
+
+		uint32 composite_bits;
+		mp_t junk;
+
+		gmp2mp(dat->tmp1, &junk);
+		composite_bits = factor_list_add(obj, 
+					factor_list, &junk);
+
+		/* We are done if composite_bits condition is satisfied 
+		   set status to 1 to prevent other threads from interfering */
+		if (composite_bits < SMALL_COMPOSITE_CUTOFF_BITS) {
+			if (pthread_mutex_lock(status_mutex)) {
+				perror("pthread_mutex_lock for status_mutex");
+				return;
+			}
+
+			*status = 1;
+			
+			if (pthread_mutex_unlock(status_mutex)) {
+				perror("pthread_mutex_lock for status_mutex");
+				return;
+			}
+		}
+		else {
+			/* a single dependency could take hours,
+			   and if N has more than two factors then
+			   we'll need several dependencies to find
+			   them all. So at least report the smallest
+			   cofactor that we just found */
+
+			mpz_divexact(dat->tmp2, init->n, dat->tmp1);
+			gmp_sprintf(obj->mp_sprintf_buf, "%Zd",
+					(mpz_cmp(dat->tmp1, dat->tmp2) < 0) ? 
+					dat->tmp1 : dat->tmp2);
+			logprintf(obj, "found factor: %s\n",
+					obj->mp_sprintf_buf);
+		}
+
+		if (pthread_mutex_unlock(factor_found_mutex)) {
+			perror("pthread_mutex_unlock for factor found");
+			return;
+		}
+	}
+}
+
+
+/*------------------------------------------------------------------
+
+Modification to msieve version 1.52
+
+Method: nfs_find_factors_threaded()
+
+Implements a threaded version of nfs_find_factors(), where multiple
+dependencies are worked on at the same time. This eliminates the 
+non-deterministic runtime of nfs_find_factors(), where the time taken
+would scale linearly with the number of "bad" dependencies it encounters.
+
+Currently, all threads are given new tasks at the same time. This is
+to allow all of the threads to finish first, and allow the master thread
+to check if the factor has been found. 
+
+A modification that could be made in the future to modify the threading
+code to allow each thread to be killed at any time. This is a major
+nightmare due to the fact that mutexes are involved and memory is freed
+during the execution of thread, so I have not implemented it here.
+
+As we must wait for all threads to complete, there is a ~10% overhead
+here compared to the time it takes to work on one dependency only.
+
+-------------------------------------------------------------------*/
+
+uint32 nfs_find_factors_threaded(msieve_obj *obj, mpz_t n, 
+			factor_list_t *factor_list) {
+
+	/* external interface for the NFS square root */
+
+	uint32 i, j;
+	sqrt_data *dat; 
+	uint32 *dep_lower;
+	uint32 *dep_upper;
+	time_t cpu_time;
+	uint32 num_threads;
+	thread_control_t control;
+	relation_lists_t *rlists;
+	struct threadpool *pool;
+	pthread_mutex_t *status_mutex;
+	pthread_mutex_t *factor_found_mutex;
+	pthread_cond_t *status_cond;
+	pthread_mutex_t *count_mutex;
+	int *status;
+	int *count;
+	int result;
+	sqrt_thread_data *thread_dat;
+
+	logprintf(obj, "\n");
+	logprintf(obj, "commencing square root phase\n");
+
+	/* Allocate memory for sqrt_data, mutexes etc. */
+	dat = (sqrt_data *)xcalloc((size_t) 1, sizeof(sqrt_data));
+	sqrt_data_init(dat);
+
+	status = (int *)xmalloc(sizeof(int));
+	*status = 0;
+	count = (int *)xmalloc(sizeof(int));
+	*count = 0;
+	dep_lower = (uint32 *)xmalloc(sizeof(uint32));
+	*dep_lower = 1;
+	dep_upper = (uint32 *)xmalloc(sizeof(uint32));
+	*dep_upper = 64;
+	factor_found_mutex = (pthread_mutex_t *)xmalloc(sizeof(pthread_mutex_t));
+	status_mutex = (pthread_mutex_t *)xmalloc(sizeof(pthread_mutex_t));
+	status_cond = (pthread_cond_t *)xmalloc(sizeof(pthread_cond_t));
+	count_mutex = (pthread_mutex_t *)xmalloc(sizeof(pthread_mutex_t));
+
+	/* read in the NFS polynomials */
+
+	cpu_time = time(NULL);
+	if (read_poly(obj, n, dat->rpoly, dat->apoly, NULL)) {
+		logprintf(obj, "polynomials not found\n");
+		goto finished;
+	}
+
+	/* find the values needed to convert the algebraic 
+	   square root back to an integer */
+
+	if (dat->rpoly->degree != 1) {
+		logprintf(obj, "cannot handle non-linear polynomials\n");
+		goto finished;
+	}
+
+	/* construct a monic version of the algebraic poly,
+	   saving off the leading coefficient separately */
+
+	j = dat->apoly->degree;
+	if (mpz_cmp_ui(dat->apoly->coeff[j], 0) < 0) {
+		logprintf(obj, "cannot handle negative leading "
+				"algebraic polynomial coefficient\n");
+		goto finished;
+	}
+
+	mpz_set(dat->c, dat->apoly->coeff[j]);
+	mpz_set(dat->tmp1, dat->c);
+	mpz_set(dat->monic_alg_poly.coeff[j-1], dat->apoly->coeff[j-1]);
+	dat->monic_alg_poly.degree = j;
+	mpz_set_ui(dat->monic_alg_poly.coeff[j], 1);
+
+	for (i = j - 2; (int32)i >= 0; i--) {
+		mpz_mul(dat->monic_alg_poly.coeff[i], dat->apoly->coeff[i], dat->tmp1);
+		if (i > 0)
+			mpz_mul(dat->tmp1, dat->tmp1, dat->c);
+	}
+	get_prime_for_sqrt(&(dat->monic_alg_poly), (uint32)0x80000000, 
+		               &(dat->check_q));
+
+	/* determine the list of dependencies to compute */
+
+	if (obj->nfs_args != NULL) {
+
+		const char *tmp;
+		const char *lower_limit;
+		const char *upper_limit;
+
+		tmp = strstr(obj->nfs_args, "dep_first=");
+		if (tmp != NULL)
+			*dep_lower = strtoul(tmp + 10, NULL, 10);
+
+		tmp = strstr(obj->nfs_args, "dep_last=");
+		if (tmp != NULL)
+			*dep_upper = strtoul(tmp + 9, NULL, 10);
+
+		/* old-style 'X,Y' format */
+
+		upper_limit = strchr(obj->nfs_args, ',');
+		if (upper_limit != NULL) {
+			lower_limit = upper_limit - 1;
+			while (lower_limit > obj->nfs_args &&
+				isdigit(lower_limit[-1])) {
+				lower_limit--;
+			}
+			upper_limit++;
+			*dep_lower = strtoul(lower_limit, NULL, 10);
+			*dep_upper = strtoul(upper_limit, NULL, 10);
+		}
+
+		*dep_lower = MAX(*dep_lower, 1);
+		*dep_upper = MAX(*dep_upper, 1);
+		*dep_lower = MIN(*dep_lower, 64);
+		*dep_upper = MIN(*dep_upper, 64);
+		logprintf(obj, "Sqrt: Handling dependencies %u to %i\n",
+				*dep_lower, *dep_upper);
+	}
+
+	logprintf(obj,"Sqrt: getting relations for each dependency\n");
+	/* Grab all of the relations for each dependency */
+	nfs_read_cycles_threaded(obj, &(dat->fb), &rlists, dep_lower, dep_upper);
+
+	if (rlists == NULL) {
+		logprintf(obj, "Sqrt: Could not process dependency cycle relations.\n");
+		goto finished;
+	}
+
+	/* Time to distribute the tasks to the threads! */
+
+	/* Initialize threadpool and mutexes */
+	logprintf(obj,"Sqrt: initializing threads\n");
+	num_threads = MIN(obj->num_threads, *dep_upper - *dep_lower + 1);
+	logprintf(obj, "Sqrt using %u threads\n", num_threads);
+	control.init = NULL;
+    control.shutdown = NULL;
+    control.data = NULL;
+	pool = threadpool_init(num_threads, (*dep_upper - *dep_lower + 1) * 2,
+						   &control);
+
+	if (pthread_mutex_init(factor_found_mutex, NULL)) {
+		perror("pthread mutex init...");
+		goto finished;
+	}
+	if (pthread_mutex_init(status_mutex, NULL)) {
+		perror("pthread mutex init...");
+		goto finished;
+	}
+	if (pthread_cond_init(status_cond, NULL)) {
+		perror("pthread cond init...");
+		goto finished;
+	}
+	if (pthread_mutex_init(count_mutex, NULL)) {
+		perror("pthread mutex init...");
+		goto finished;
+	}
+
+	/* Prepare the thread data needed for each dependency task */
+	thread_dat = (sqrt_thread_data *)xcalloc((size_t) (*dep_upper - 
+											 		   *dep_lower + 1), 
+									         sizeof(sqrt_thread_data));
+
+	for (i = *dep_lower; i <= *dep_upper; i++) {
+		relation_lists_t *rl = rlists + i - *dep_lower;
+		sqrt_thread_data *data = thread_dat + i - *dep_lower;
+
+		sqrt_thread_data_init(obj, data, dat, rl, 
+				factor_found_mutex, status_mutex, 
+				status_cond, status, count_mutex, 
+				count, n, factor_list);
+	}
+
+	if (pthread_mutex_lock(status_mutex)) {
+		perror("pthread mutex lock...");
+		goto finished;
+	}
+
+	while (*status == 0) {
+		if (pthread_mutex_lock(count_mutex)) {
+			perror("pthread_mutex_lock");
+			goto finished;
+		}
+
+		/* Add tasks in a batch fashion to avoid unusual thread conditions 
+
+		   Tthis could be overhauled in the future if threadpool.c 
+		   and sqrt_thread_find_factor supports task cancellation allowing
+		   for all of the tasks to be added at the same time */
+
+		if (*count == *dep_upper - *dep_lower + 1) {
+			logprintf(obj, "Sqrt: All dependencies have been tried and have "
+					  "failed. Exiting...\n");
+			*status = -1;
+		}
+
+		/* If the batch is completed, add more tasks */
+		if (*count % num_threads == 0) {
+			uint32 start_dep = MIN(*dep_lower + *count, *dep_upper);
+			uint32 end_dep = MIN(start_dep + num_threads - 1, *dep_upper);
+			logprintf(obj, "Sqrt: Adding dependencies %u to %u "
+			 		  "to the task pool\n", start_dep, end_dep);
+
+			for (i = start_dep; i <= end_dep; i++) {
+				sqrt_thread_data *data = thread_dat + i - *dep_lower;
+				task_control_t t;
+				t.init = NULL;
+				t.run = sqrt_thread_find_factor;
+				t.data = data;
+				t.shutdown = sqrt_thread_shutdown;
+				threadpool_add_task(pool, &t, 1);
+			}
+		}
+
+		if (pthread_mutex_unlock(count_mutex)) {
+			perror("pthread_mutex_lock");
+			goto finished;
+		}
+		pthread_cond_wait(status_cond, status_mutex);
+	}
+
+	if (pthread_mutex_unlock(status_mutex)) {
+		perror("pthread mutex unlock...");
+		goto finished;
+	}
+
+	/* freeing up the threadpool and remaining unused dep data */
+	threadpool_free(pool);
+	for (i = *dep_lower + *count; i<=*dep_upper; i++) {
+		free_sqrt_thread_data(thread_dat + i - *dep_lower);
+	}
+	free(thread_dat);
+
+finished:
+	result = *status == -1 ? 0 : 1;
+	cpu_time = time(NULL) - cpu_time;
+	
+	free_sqrt_data(dat);
+	pthread_mutex_destroy(status_mutex);
+	pthread_mutex_destroy(factor_found_mutex);
+	pthread_mutex_destroy(count_mutex);
+	pthread_cond_destroy(status_cond);
+	free(status_mutex);
+	free(factor_found_mutex);
+	free(count_mutex);
+	free(status_cond);
+	free(status);
+	free(count);
+	free(dep_lower);
+	free(dep_upper);
+	logprintf(obj, "sqrtTime: %u\n", (uint32)cpu_time);
+	return result;
+}
diff -Naur ./msieve-1.52/gnfs/sqrt/sqrt.h ./msieve-custom/gnfs/sqrt/sqrt.h
--- ./msieve-1.52/gnfs/sqrt/sqrt.h	2011-09-11 11:31:19.000000000 -0400
+++ ./msieve-custom/gnfs/sqrt/sqrt.h	2015-10-11 20:16:47.000000000 -0400
@@ -16,11 +16,187 @@
 #define _GNFS_SQRT_SQRT_H_
 
 #include "gnfs.h"
+#include <thread.h>
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
+/*------------------------------------------------------------------
+
+Modification to msieve version 1.52
+
+Method: sqrt_fb_light_init()
+
+This is performs a light initialization of the mpz_poly structs
+in the factor_base_t.
+
+Used only in sqrt_data_init()
+
+-------------------------------------------------------------------*/
+
+void sqrt_fb_light_init (factor_base_t *fb);
+
+/*------------------------------------------------------------------
+
+Modification to msieve version 1.52
+
+Method: sqrt_fb_light_copy_a_r_poly()
+
+This is performs a light copy of the mpz_poly structs
+in the factor_base_t.
+
+Used only in sqrt_data_deep_copy()
+
+-------------------------------------------------------------------*/
+
+void sqrt_fb_light_copy_a_r_poly (factor_base_t *dst, factor_base_t *src);
+
+/*------------------------------------------------------------------
+
+Modification to msieve version 1.52
+
+Struct: sqrt_data
+
+Contains all of the data necessary for the sqrt stage, to be passed
+to each thread.
+
+-------------------------------------------------------------------*/
+
+typedef struct {
+	uint32 check_q;
+	factor_base_t fb;
+	mpz_poly_t monic_alg_poly;
+	mpz_poly_t *rpoly;
+	mpz_poly_t *apoly;
+	mpz_t exponent, sqrt_r, sqrt_a;
+	mpz_t c, tmp1, tmp2;
+} sqrt_data;
+
+/*------------------------------------------------------------------
+
+Modification to msieve version 1.52
+
+Method: sqrt_data_init()
+
+This is performs a initialization of the sqrt_data struct.
+
+Used in sqrt_data_deep_copy() and nfs_find_factors_threaded().
+
+-------------------------------------------------------------------*/
+
+void sqrt_data_init (sqrt_data *dat);
+
+/*------------------------------------------------------------------
+
+Modification to msieve version 1.52
+
+Method: sqrt_data_deep_copy()
+
+This is performs a deep copy of the sqrt_data struct. Only pass 
+in an uninitialized, but memory allocated, sqrt_data pointer as
+dst. The current method does not do the correct checking to
+ensure memory-safety otherwise.
+
+Used in nfs_find_factors_threaded() in order to make a copy of
+sqrt_data for each of the threads.
+
+-------------------------------------------------------------------*/
+
+void sqrt_data_deep_copy (sqrt_data *dst, sqrt_data *src);
+
+/*------------------------------------------------------------------
+
+Modification to msieve version 1.52
+
+Method: free_sqrt_data()
+
+Frees sqrt_data.
+
+Used in nfs_find_factors_threaded() and sqrt_thread_shutdown()
+
+-------------------------------------------------------------------*/
+
+void free_sqrt_data (sqrt_data *dat);
+
+/*------------------------------------------------------------------
+
+Modification to msieve version 1.52
+
+Struct: sqrt_thread_data
+
+Contains all of the data necessary for each thread to compute its
+dependency.
+
+-------------------------------------------------------------------*/
+
+typedef struct {
+	pthread_mutex_t *factor_found_mutex;
+	pthread_mutex_t *status_mutex;
+	pthread_cond_t *status_cond;
+	pthread_mutex_t *count_mutex;
+	int *status;
+	int *count;
+	uint32 num_relations;
+	uint32 num_free_relations;
+	relation_t *rlist;
+	abpair_t *abpairs;
+	sqrt_data *dat;
+	uint32 dep_no;
+	msieve_obj *obj;
+	mpz_t n;
+	factor_list_t *factor_list;
+
+} sqrt_thread_data;
+
+/*------------------------------------------------------------------
+
+Modification to msieve version 1.52
+
+Method: sqrt_thread_data_init()
+
+Initializes the data object required by each thread.
+
+Used in nfs_find_factors_threaded().
+
+-------------------------------------------------------------------*/
+
+void sqrt_thread_data_init(msieve_obj *obj, 
+				sqrt_thread_data *thread_dat, 
+				sqrt_data *dat, relation_lists_t *rl, 
+				pthread_mutex_t *factor_found_mutex,
+				pthread_mutex_t *status_mutex, 
+				pthread_cond_t *status_cond, int *status, pthread_mutex_t *count_mutex, 
+				int *count, mpz_t n, factor_list_t *factor_list);
+
+/*------------------------------------------------------------------
+
+Modification to msieve version 1.52
+
+Method: free_sqrt_thread_data()
+
+Frees the thread data object upon completion of the thread.
+
+Used in nfs_find_factors_threaded() and sqrt_thread_shutdown().
+
+-------------------------------------------------------------------*/
+
+void free_sqrt_thread_data(sqrt_thread_data *data);
+
+/*------------------------------------------------------------------
+
+Modification to msieve version 1.52
+
+Method: sqrt_thread_shutdown()
+
+Performs necessary clean up of thread data after the task is complete.
+
+Used in nfs_find_factors_threaded().
+
+-------------------------------------------------------------------*/
+
+void sqrt_thread_shutdown(void *arg, int thread_num);
+
 uint32 get_prime_for_sqrt(mpz_poly_t *alg_poly,
 			  uint32 min_value,
 			  uint32 *q_out); 
diff -Naur ./msieve-1.52/gnfs/sqrt/sqrt_a.c ./msieve-custom/gnfs/sqrt/sqrt_a.c
--- ./msieve-1.52/gnfs/sqrt/sqrt_a.c	2013-06-07 21:43:54.000000000 -0400
+++ ./msieve-custom/gnfs/sqrt/sqrt_a.c	2015-10-11 20:16:47.000000000 -0400
@@ -590,7 +590,7 @@
 			mpz_t m0, abpair_t *rlist, 
 			uint32 num_relations, uint32 check_q,
 			mpz_t sqrt_a) {
-	
+
 	/* external interface for computing the algebraic
 	   square root */
 
@@ -690,5 +690,5 @@
 	mpz_poly_free(&alg_sqrt);
 	mpz_poly_free(&d_alg_poly);
 	mpz_clear(q);
-	alg_poly->degree++;
-}
+	alg_poly->degree++;	
+}
\ No newline at end of file
diff -Naur ./msieve-1.52/include/common.h ./msieve-custom/include/common.h
--- ./msieve-1.52/include/common.h	2013-08-07 20:19:23.000000000 -0400
+++ ./msieve-custom/include/common.h	2015-10-11 20:16:47.000000000 -0400
@@ -284,6 +284,26 @@
 	la_cycle_t cycle;       /* list of relations comprising this column */
 } la_col_t;
 
+/*------------------------------------------------------------------
+
+Modification to msieve version 1.52
+
+Struct: la_dep_t
+
+This struct allows for a list of dependencies to be created, each
+containing a list of cycles. 
+
+Used to collect cycles in read_cycles_threaded() and then relations
+in nfs_get_cycle_relations_threaded().
+
+-------------------------------------------------------------------*/
+
+typedef struct {
+	la_col_t *column;
+	uint32 num_cycles;
+	uint32 curr_cycle;
+} la_dep_t;
+
 /* merge src1[] and src2[] into merge_array[], assumed
    large enough to hold the merged result. Return the
    final number of elements in merge_array */
@@ -335,6 +355,32 @@
 		uint32 dependency,
 		uint32 *colperm);
 
+/*------------------------------------------------------------------
+
+Modification to msieve version 1.52
+
+Method: read_cycles_threaded()
+
+This is a modified version of read_cycles() that enables the 
+threading of the square root stage. 
+
+The key modification is that it creates lists of cycles (and relation
+ids within them) for each of the dependencies in one pass of the .cyc
+ cycle file.
+
+It also takes in uint32 pointers for dep_lower and dep_upper. This
+allows for the modification of dep_lower and dep_upper, as some of 
+the dependencies will not contain any cycles. This differs from the 
+original code, which due to its sequential nature would normally "hit"
+a "good" dependency before running out of dependencies.
+
+-------------------------------------------------------------------*/
+
+void read_cycles_threaded(msieve_obj *obj, 
+		la_dep_t **dep_cycle_list_out, 
+		uint32 *dep_lower,
+		uint32 *dep_upper);
+
 /*-------------- MISCELLANEOUS STUFF ----------------------------------*/
 
 #define POSITIVE 0
diff -Naur ./msieve-1.52/include/thread.h ./msieve-custom/include/thread.h
--- ./msieve-1.52/include/thread.h	2012-11-11 09:58:30.000000000 -0500
+++ ./msieve-custom/include/thread.h	2015-10-11 20:16:47.000000000 -0400
@@ -99,7 +99,6 @@
 int threadpool_drain(struct threadpool *pool,
 			int blocking);
 
-
 #ifdef __cplusplus
 }
 #endif
